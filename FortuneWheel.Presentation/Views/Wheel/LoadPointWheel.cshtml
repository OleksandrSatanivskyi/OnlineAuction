@model global::WheelOfFortune.Models.Wheels.LoadPointWheelModel
@{
    Layout = "_WheelsLayout";
}

<div class="load-wheel-container">
    <div class="spin-wheel-header">
        <h1 id="winner">NONE</h1>
    </div>
    <div class="wheel">
        <canvas class="" id="canvas" width="800" height="800"></canvas>

        <div class="center-circle" onclick="spin()">
            <div class="triangle"></div>
        </div>

    </div>
</div>

<script>
    function toRad(deg) {
        return deg * (Math.PI / 180.0);
    }
    function randomRange(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function easeOutSine(x) {
        return Math.sin((x * Math.PI) / 2);
    }
    function getPercent(input, min, max) {
        return (((input - min) * 100) / (max - min)) / 100
    }

    function hexToRgb(hex) {
        hex = hex.replace(/^#/, '');

        let r = parseInt(hex.substring(0, 2), 16);
        let g = parseInt(hex.substring(2, 4), 16);
        let b = parseInt(hex.substring(4, 6), 16);

        return { r, g, b };
    }

    const canvas = document.getElementById("canvas")
    const ctx = canvas.getContext("2d")
    const width = document.getElementById("canvas").width
    const height = document.getElementById("canvas").height

    const centerX = width / 2
    const centerY = height / 2
    const radius = width / 2

    let segmentsData = @Html.Raw(Json.Serialize(Model.RemainingOptions));
    let totalPoints = segmentsData.reduce((total, segment) => total + (segment.points), 0);

    let segments = segmentsData.map(function (segment) {
        return {
            id: segment.id,
            title: segment.title,
            colorHex: segment.colorHex,
            width: (segment.points * 360) / totalPoints
        };
    });

    console.log(segments);


    let currentDeg = 0
    let itemDegs = {}

    draw();

    function draw() {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, toRad(0), toRad(360))
        ctx.fillStyle = `rgb(${33},${33},${33})`
        ctx.lineTo(centerX, centerY);
        ctx.fill()

        let startDeg = currentDeg;
        for (let i = 0; i < segments.length; i++) {
            let endDeg = startDeg + segments[i].width;
            color = hexToRgb(segments[i].colorHex);
            let colorStyle = `rgb(${color.r},${color.g},${color.b})`

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 2, toRad(startDeg), toRad(endDeg))
            let colorStyle2 = `rgb(${color.r - 30},${color.g - 30},${color.b - 30})`
            ctx.fillStyle = colorStyle2
            ctx.lineTo(centerX, centerY);
            ctx.fill()

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 10, toRad(startDeg), toRad(endDeg))
            ctx.fillStyle = colorStyle
            ctx.lineTo(centerX, centerY);
            ctx.fill()

            drawSegmentSeparator(centerX, centerY, radius, startDeg, endDeg);

            drawSeparator(centerX, centerY, radius - 1, startDeg, endDeg);

            // draw text
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(toRad((startDeg + endDeg - 3) / 2));
            ctx.textAlign = "left";
            if (color.r > 150 || color.g > 150 || color.b > 150) {
                ctx.fillStyle = "#000";
            }
            else {
                ctx.fillStyle = "#fff";
            }
            ctx.font = ctx.font = '16px Arial';

            let text = segments[i].title;
            let textWidth = ctx.measureText(text).width;
            let availableWidth = 180;
            if (textWidth > availableWidth) {
                let charsThatFit = Math.floor((availableWidth - ctx.measureText('...').width) / textWidth * text.length);
                text = text.substring(0, charsThatFit - 3) + '...';
            }

            if (textWidth / 3 > endDeg - startDeg) {
                text = "";
            }

            ctx.fillText(text, 130, 10);
            ctx.restore();

            itemDegs[segments[i].id] =
            {
                "startDeg": startDeg,
                "endDeg": endDeg
            }

            if (startDeg % 360 <= 270 && endDeg % 360 > 270) {
                document.getElementById("winner").innerHTML = segments[i].title;
            }

            startDeg = endDeg;
        }
    }

    function drawSegmentSeparator(centerX, centerY, radius, startDeg, endDeg) {
        let middleDeg = (endDeg);
        let middleRad = toRad(middleDeg);

        let x = centerX + radius * Math.cos(middleRad);
        let y = centerY + radius * Math.sin(middleRad);

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(x, y);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.stroke();
    }

    function drawSeparator(centerX, centerY, radius, startDeg, endDeg) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, toRad(startDeg), toRad(endDeg));
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.stroke();
    }

    let speed = 0
    let maxRotation = randomRange(360 * 3, 360 * 6)
    let pause = false
    function animate() {
        if (pause) {
            return
        }
        speed = easeOutSine(getPercent(currentDeg, maxRotation, 0)) * 20
        if (speed < 0.01) {
            speed = 0
            pause = true
        }
        currentDeg += speed
        draw()
        window.requestAnimationFrame(animate);
    }

    function spin() {
        if (speed != 0) {
            return
        }

        maxRotation = 0;
        currentDeg = 0;
        segmentWidth = 360 / segments.length;
        draw();

        var randomId = Math.floor(Math.random() * segments.length);
        maxRotation = (360 * 8) - itemDegs[segments[randomId].id].endDeg + Math.floor(Math.random() * 200) + 1
        itemDegs = {}
        pause = false
        window.requestAnimationFrame(animate);
    }

</script>